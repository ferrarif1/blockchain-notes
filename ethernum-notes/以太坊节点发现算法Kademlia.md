Kademlia算法是一种分布式存储及路由的算法

为了讲解分布式存储及路由的算法，以我们熟悉的场景来举例：从学校图书馆变成一个1000个学生组成的分布式图书馆，来讲解Kademlia算法如何实现分布式存储及路由的原理。

从问题入手


节点要素

学生存储的书以<key, value>键值对的形式存储

学生的学号---》节点的ID学生的手机号码---》节点的IP地址及端口

每位同学需要维护的内容：1从图书馆分发下来的书本（被分配到需要存储的内容）:2一个通讯录：包含一小部分其他同学的学号和手机号，

有人会问，为什么不是每个同学都有全量通讯录

其一，分布式系统中节点的进入和退出是相当频繁的，每次有变动时都全网广播通讯录更新，通讯量会很大；其二，一旦任意一个同学被坏人绑架了（节点被黑客攻破），则坏人马上就拥有了所有人的手机号码，这并不安全。

文件的存储及查找
符合以下特性：1）分布均匀：2）查找方便：

Kademlia设计如下：假设《分布式算法》这本书的书名的hash值是 00010000，即Hash(《分布式算法》书) = 00010000-->那么《分布式算法》应该存在学号为00010000的同学手上。
所以这要求hash算法的取值范围与node ID的取值范围一致

也就是说我通过hash(书名) 能找到对应的同学 的学号

万一学号为00010000的同学今天没来上学，那《分布式算法》这本书岂不是谁都拿不到了？那算法要求这本书不能只存在一个同学手上，而是被要求同时存储在多个同学手上。

分布式存储的特点就是：通过冗余存储和备份

如何指定哪些同学需要存储这本分布式算法这本书，使得书能够被快速找到：最接近00010000的k位同学手上，即00010001、00010010、00010011…等同学手上都会有这本书。

所以：当你需要找《分布式算法》这本书时，将书名hash一下，得到 00010000，这个便是索书号，你就知道该找哪（几）位同学了。剩下的问题，就是找到这（几）位同学的手机号。



针对上面文件的存储和查找：有几个问题：
1最接近00010000的k位同学手上，即00010001、00010010、00010011…等同学手上都会有这本书。。。。最接近的定义是什么？
2由于你手上只有一部分同学的通讯录，你很可能并没有00010000的手机号（IP地址）。那如何联系上00010000同学呢？

接下来我们先引入一个基本概念：节点的异或距离
简单介绍下异或的运算法则：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）

举2个学号（Node ID）之间的异或距离例子，大家加深印象：01010000与01010010距离（即是2个ID的异或值）为00000010，换算为十进制即为2；0101000001010010-------------------0000001001000000与00000001距离为01000001，换算为十进制即为2**6+1，即65；

概念2：通讯录的距离分层：

设置0000110为节点A，如果一个节点的ID只有最后一位与节点A不同，这样的节点只有1个——0000111，与节点A的异或值为0000001，即距离为1对于0000110而言，这样的节点归为“k-bucket 1”；

如果一个节点的ID，前面所有位数相同，从倒数第2位开始不同，这样的节点只有2个：0000101、0000100，与节点A的异或值为0000011和0000010，即距离范围为3和2；对于0000110而言，这样的节点归为“k-bucket 2”；


以此类推
如果一个节点的ID，前面所有位数相同，从倒数第i位开始不同，即从倒数第i位到最后一位，每一位都有两种情况(0和1)这样的节点就有2(i-1)个，与节点A的距离范围为[2(i-1), 2i）；对于0000110而言，这样的节点归为“k-bucket i”；
对上面描述的另一种理解方式：如果将整个网络的节点梳理为一个按节点ID排列的二叉树，树最末端的每个叶子便是一个节点，则下图就比较直观的展现出，节点之间的距离的关系。


回到我们的类比。每个同学只维护一部分的通讯录，这个通讯录按照距离分层（可以理解为按学号与自己的学号从第几位开始不同而分层），即k-bucket1, k-bucket 2, k-bucket 3…虽然每个k-bucket中实际存在的同学人数逐渐增多，但每个同学在它自己的每个k-bucket中只记录k位同学的手机号（k个节点的地址与端口，注:这里的k是一个可调节的常量参数）

节点的定位是Kademlia算法的核心

A同学计算自己与Z同学学号的异或距离为:00010110，距离范围在[2^4, 2^5)，所以这个Z同学可能在k-bucket 5中（或者直观地说，Z同学的学号与A同学的学号从第5位开始不同，所以Z同学可能在k-bucket 5中）。0000011000010000——————00010110
然后A同学看看自己的k-bucket 5有没有Z同学：
>如果有，那就直接联系Z同学要书；
>如果没有，在k-bucket 5里随便找一个B同学（关键点：注意任意B同学，它的学号第5位肯定与Z相同，即它与Z同学的距离会小于2^4，相当于比Z、A之间的距离缩短了一半以上），请求B同学在它自己的通讯录里按同样的查找方式找一下Z同学：

接下来：>如果B知道Z同学，那就把Z同学的手机号（IP Address）告诉A；
>如果B也不知道Z同学，那B按同样的搜索方法，可以在自己的通讯录里找到k-bucket 4中任一位C同学（Z、C之间距离小于2^3），把C同学推荐给A；A同学请求C同学进行下一步查找。
递归算法

保证对于任意n个学生，最多只需要查询log2(n)次，即可找到获得目标同学的联系方式