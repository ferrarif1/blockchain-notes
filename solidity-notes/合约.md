## 创建合约
- 合约能够通过以太坊交易”从外部“创建，也可以用solidity创建。
- 网页编辑器[Remix](https://remix.ethereum.org/#optimize=false&version=soljson-v0.5.1+commit.c8a2cb62.js)
- 在以太坊上，能够使用JS API [web3.js](https://github.com/ethereum/web3.js)来创建合约。里边有个函数叫做[web3.eth.Contract](https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract)
- 当合约被创建，将执行一次构造函数`constructor`
- 构造函数是可选的，且最多有一个。
- 构造函数执行后，合约的代码会部署到区块链上。代码包括所有的公共函数和外部函数，以及所有能够访问到的函数。但是不包括构造函数和只在构造函数调用的私有函数。

## 可访问性
- 函数有两种类型：`internal`(不创建实际的EVM调用),和`external`
- 函数和状态变量有四种可见度类型：
> - `external`:外部函数是合约接口的一部分，能够用来被**其他合约或交易调用**。当然外部函数也能在内部调用，但不是`f()`而是`this.f()`。当接收大量数据时，外部函数可能会更有效率。`external`不能用于状态变量。
> - `public`: 共有函数时合约接口的一部分，能够被**内部调用或者通过信息调用**。对于共有的状态变量，会自动生成一个getter函数。
> - `internal`:内部函数只能在**当前合约或者衍生合约**中使用，直接调用，不需要用`this`调用
> - `private`: 私有函数只能在**当前合约**中使用，不能在衍生合约中使用
- 可访问性在状态变量的类型后表明，在函数的参数列表和返回列表之间表明。
```
pragma solidity >=0.4.16 <0.7.0;

contract C {
    function f(uint a) private pure returns (uint b) { return a + 1; }
    function setData(uint a) internal { data = a; }
    uint public data;
}
```
## getter函数
- 编译器自动为所有的`public`状态变量创建getter函数。例如有个合约中有共有的状态变量data，那么在另一个合约中，创建该合约的实例c，就可以通过`c.data()`来访问data。
- getter函数具有外部可见性`external`。如果在内部访问，需要要通过this调用，执行状态变量，如果在外部访问，需要通过this调用，执行函数。
```
pragma solidity >=0.4.0 <0.7.0;

contract C {
    uint public data;
    function x() public returns (uint) {
        data = 3; // internal access
        return this.data(); // external access
    }
}
```
- 如果访问一个`public`状态变量，只能通过getter函数访问数组中的一个元素，这种机制的存在避免了返回整个数组的高额gas成本，例如`data(0)`，如果想要返回整个数组，需要写一个函数。
```
pragma solidity >=0.4.0 <0.7.0;

contract arrayExample {
  // public state variable
  uint[] public myArray;

  // Getter function generated by the compiler
  /*
  function myArray(uint i) returns (uint) {
      return myArray[i];
  }
  */

  // function that returns entire array
  function getArray() returns (uint[] memory) {
      return myArray;
  }
}
```
## 函数修饰符 function modifiers
- 修饰符是合约的可继承属性，可以被派生合约覆盖。
```
    modifier onlyOwner {
        require(
            msg.sender == owner,
            "Only owner can call this function."
        );
        _;
    }
```
- `_`表示函数在此执行，于是可以封装一个修饰符函数作为锁，如
```
contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(
            !locked,
            "Reentrant call."
        );
        locked = true;
        _;
        locked = false;
    }

    /// This function is protected by a mutex, which means that
    /// reentrant calls from within `msg.sender.call` cannot call `f` again.
    /// The `return 7` statement assigns 7 to the return value but still
    /// executes the statement `locked = false` in the modifier.
    function f() public noReentrancy returns (uint) {
        (bool success,) = msg.sender.call("");
        require(success);
        return 7;
    }
}
```
- 多个修饰符作用于一个函数，可以将他们放在列表中通过空格分隔，按顺序执行。

## 常量`constant`
状态变量可以声明为常量`constant`,在这种情况下，他们接收的表达式必须是常量，在编译时被分配。任何表达式来访问storage,区块链数据(如`now, address(this).balance or block.number`)或者执行数据(`msg.value, gasleft()`)或者调用外部的合约是不允许的。可能对内存发配产生副作用的表达式可能是允许的，但是那些对内存对象产生副作用的表达式是不允许的。这些内置函数`keccak256, sha256, ripemd160, ecrecover, addmod and mulmod`是允许的。（尽管除了`keccak256`，这些确实调用了外部合约）

在内存分配上允许副作用背后的原因是，应该可以构造复杂的对象，比如查找表。 这个特性还没有完全可用。

现在仅支持值类型和字符串。
```
pragma solidity >=0.4.0 <0.7.0;

contract C {
    uint constant x = 32**22 + 8;
    string constant text = "abc";
    bytes32 constant myHash = keccak256("abc");
}
```
## 返回值
- `returns` 用于声明，`return`用于代码中
- 可以返回多个值

## view
- 函数被`view`声明，在这种情况下，保证它们不修改状态。
- 以下被认为是对状态的修改
> - 写入状态变量
> - emitting 事件
> - 创建其它合约
> - 使用`selfdestruct`
> - 通过调用发送ether
> - 调用任何未用`view`或`pure`标记的函数。
> - 使用低级别的调用
> - 使用包含某些操作码的内联汇编
- getter方法自动标记为`view`

## pure函数
- 函数可以声明为`pure`，在这种情况下，它们承诺不读取或者修改状态。
- 以下被认为是读取状态
> - 读取状态变量
> - 访问`address(this).balance`或`<address>.balance`
> - 访问`block,tx,msg`的成员（`msg.sig, msg.data`除外）
> - 使用`selfdestruct`
> - 通过调用发送ether
> - 调用任何未用`pure`标记的函数。
> - 使用包含某些操作码的内联汇编
- pure函数在错误发生时，可以使用`revert()`和`require()`函数来恢复潜在的更改状态。

## 回退函数 fallback function
- 合约可以只拥有一个未命名的函数。这个函数不能有参数，不能返回任何东西，并且必须用`external`标识。如果调用合约的函数未能匹配到，则在合约中调用它
- 如果需要支付或接收ehter的话，必须用`payable`标记。
- 在最坏的情况下，回退函数只能调用2300 gas(用于`send or tarnsfer`),除了基本的日志记录外，没有其它操作的空间。下列操作需要花费的gas超过2300：
> - 写入`storage`
> - 创建合约
> - 调用需要消耗大量gas的外部函数
> - 发送ether

## 函数重载
- 方法名相同，参数不同。

## events
solidity events 在EVM的日志功能 之上提供了一个抽象。应用程序可以通过以太坊的客户端的RPC接口来订阅和监听这些事件。

events 是合约中的可继承成员。调用它们时，它们会将参数存储在交易日志中-区块链中一个特殊的数据结构。这些日志和合约地址关联，被合并到区块链中，只要有一个块被访问它就会一直存在。日志和event数据不能通过合约访问。

可以为日志请求一个简单的支付验证（SPV),因此如果一个外部实体提供了这样一个验证合约，它可以检查日志实际上存在于区块链中。 你必须提供块头，因为合约只能看到最后的256个块的hash。

你能最多为三个参数添加属性`indexed`，这将会将他们添加到一个特殊的数据结构`topics`，而不是日志数据。如果使用数组（包括`string bytes`）作为被索引的参数，它的Keccak-256哈希值会被存储为topic，因为topic只能容纳32字节的单词。

没有索引的所有参数都会被[ ABI-encoded](https://solidity.readthedocs.io/en/v0.5.6/abi-spec.html#abi)到日志的数据部分。

topic允许你搜索event，例如筛选某些事件的块序列。你也能根据发送事件的合约地址来筛选事件。

例如，这个代码使用web3.js的`subscribe("logs"`方法来过滤拥有特定地址的事件来匹配一个topic
```
var options = {
    fromBlock: 0,
    address: web3.eth.defaultAccount,
    topics: ["0x0000000000000000000000000000000000000000000000000000000000000000", null, null]
};
web3.eth.subscribe('logs', options, function (error, result) {
    if (!error)
        console.log(result);
})
    .on("data", function (log) {
        console.log(log);
    })
    .on("changed", function (log) {
});
```

事件签名的hash是主题之一，除非你使用`anonymous `对事件声明。这意味着不能通过名称来过滤anonymous事件。
```
pragma solidity >=0.4.21 <0.7.0;

contract ClientReceipt {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function deposit(bytes32 _id) public payable {
        // Events are emitted using `emit`, followed by
        // the name of the event and the arguments
        // (if any) in parentheses. Any such invocation
        // (even deeply nested) can be detected from
        // the JavaScript API by filtering for `Deposit`.
        emit Deposit(msg.sender, _id, msg.value);
    }
}
```

在JS的API中使用如下：
```
var abi = /* abi as generated by the compiler */;
var ClientReceipt = web3.eth.contract(abi);
var clientReceipt = ClientReceipt.at("0x1234...ab67" /* address */);

var event = clientReceipt.Deposit();

// watch for changes
event.watch(function(error, result){
    // result contains non-indexed arguments and topics
    // given to the `Deposit` call.
    if (!error)
        console.log(result);
});


// Or pass a callback to start watching immediately
var event = clientReceipt.Deposit(function(error, result) {
    if (!error)
        console.log(result);
});
```

输出结果如下
```
{
   "returnValues": {
       "_from": "0x1111…FFFFCCCC",
       "_id": "0x50…sd5adb20",
       "_value": "0x420042"
   },
   "raw": {
       "data": "0x7f…91385",
       "topics": ["0xfd4…b4ead7", "0x7f…1a91385"]
   }
}
```

### 日志的低级接口
还可以通过 `log0、 log1、 log2、 log3和 log4`函数访问到日志机制的底层接口。`logi`接受`i+1`个`bytes32`类型的参数，其中第一个参数会被用来作为日志的数据部分，其它会被作为主题。上面的时间调用能够表现为
```
pragma solidity >=0.4.10 <0.7.0;

contract C {
    function f() public payable {
        uint256 _id = 0x420042;
        log3(
            bytes32(msg.value),
            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),
            bytes32(uint256(msg.sender)),
            bytes32(_id)
        );
    }
}
```

其中的长的十六进制数等于`keccak256("Deposit(address,bytes32,uint256)")`，即事件的签名。

### events的其它资源
- [JS文档](https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events)
- [example](https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol)
- [在JS中使用](https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js)

## 继承
solidity支持多继承，包括多态。

所有的函数调用都是虚拟的，这意味着调用派生最多的函数，除非显式地给出合约名称或者使用关键字`super`

当一个合约继承了其他合约时，只有一个合约被创建在区块链上，其他基础合约代码被编译到创建的合约中。
```
pragma solidity >=0.5.0 <0.7.0;

contract owned {
    constructor() public { owner = msg.sender; }
    address payable owner;
}

// Use `is` to derive from another contract. Derived
// contracts can access all non-private members including
// internal functions and state variables. These cannot be
// accessed externally via `this`, though.
contract mortal is owned {
    function kill() public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

// These abstract contracts are only provided to make the
// interface known to the compiler. Note the function
// without body. If a contract does not implement all
// functions it can only be used as an interface.
contract Config {
    function lookup(uint id) public returns (address adr);
}

contract NameReg {
    function register(bytes32 name) public;
    function unregister() public;
 }

// Multiple inheritance is possible. Note that `owned` is
// also a base class of `mortal`, yet there is only a single
// instance of `owned` (as for virtual inheritance in C++).
contract named is owned, mortal {
    constructor(bytes32 name) public {
        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
        NameReg(config.lookup(1)).register(name);
    }

    // Functions can be overridden by another function with the same name and
    // the same number/types of inputs.  If the overriding function has different
    // types of output parameters, that causes an error.
    // Both local and message-based function calls take these overrides
    // into account.
    function kill() public {
        if (msg.sender == owner) {
            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
            NameReg(config.lookup(1)).unregister();
            // It is still possible to call a specific
            // overridden function.
            mortal.kill();
        }
    }
}

// If a constructor takes an argument, it needs to be
// provided in the header (or modifier-invocation-style at
// the constructor of the derived contract (see below)).
contract PriceFeed is owned, mortal, named("GoldFeed") {
   function updateInfo(uint newInfo) public {
      if (msg.sender == owner) info = newInfo;
   }

   function get() public view returns(uint r) { return info; }

   uint info;
}
```
用`mortal.kill()`来销毁请求，这种做法是有问题的。建议使用`super`
```
pragma solidity >=0.4.22 <0.7.0;

contract owned {
    constructor() public { owner = msg.sender; }
    address payable owner;
}

contract mortal is owned {
    function kill() public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}

contract Base1 is mortal {
    function kill() public { /* do cleanup 1 */ super.kill(); }
}


contract Base2 is mortal {
    function kill() public { /* do cleanup 2 */ super.kill(); }
}

contract Final is Base1, Base2 {
}
```
如果`Base2`调用了`super`函数，它会调用继承图谱中的下一个合约，因此它会调用`Base1.kill()。上述代码中的继承图谱为Final、 Base2、 Base1、 mortal、 owned。

## 构造函数
当构造函数运行后，合约的最终代码会部署到区块链。部署代码的花费与代码的长度成正比。此代码包括属于公共接口的所有函数，以及通过函数调用从公共接口可访问的所有函数。 它不包括只从构造函数调用的构造函数代码或内部函数。

构造函数可以是`public`的，也可以是`internal`的。 如果没有构造函数，合约将采用缺省构造函数构造函数，这相当于 `constructor () public {}`。 

### 基础构造函数的参数
如果构造函数继承了其它合约，有以下两种方式：
```
pragma solidity >=0.4.22 <0.7.0;

contract Base {
    uint x;
    constructor(uint _x) public { x = _x; }
}

// Either directly specify in the inheritance list...
contract Derived1 is Base(7) {
    constructor() public {}
}

// or through a "modifier" of the derived constructor.
contract Derived2 is Base {
    constructor(uint _y) Base(_y * _y) public {}
}
```

### 多重继承和线性
下列代码会报错 `Linearization of inheritance graph impossible`
```
pragma solidity >=0.4.0 <0.7.0;

contract X {}
contract A is X {}
// This will not compile
contract C is A, X {}
```
继承的顺序是**从右往左的**。因此C会先继承X，再继承A，但是A本身继承了X，因此线性顺序错误。

### 抽象合约
当至少有一个函数没有实现时，合约被标记为抽象。如下所示。
```
pragma solidity >=0.4.0 <0.7.0;

contract Feline {
    function utterance() public returns (bytes32);
}
```
这样的合约无法编译但是可以作为基础合约。

## 接口
接口类似于抽象合约，但是它们不能实现任何函数。另外，还有一些限制：
- 它们不能继承其他契约或接口
- 所有声明的函数必须是外部的
- 它们不能声明构造函数
- 它们不能声明状态变量

```
pragma solidity >=0.5.0 <0.7.0;

interface Token {
    enum TokenType { Fungible, NonFungible }
    struct Coin { string obverse; string reverse; }
    function transfer(address recipient, uint amount) external;
}
```

合约能够继承接口，就像它们能够继承其他合约一样。

接口内部定义的类型和其它类似合约的结构能够被其它合约访问：`Token.TokenType`或`Token.Coin`

## 库 libraries
库类似于合约，但是它们的目的是只在特定地址部署一次并且使用EVM的`DELEGATECALL`（`CALLCODE `until Homestead）功能能够重用它们的代码。这意味着，如果调用库函数，它们的代码将在调用合约的上下文中执行，也就是说，`this`指向调用合约，特别是来自调用合约的storage可以被访问。由于库是一段独立的源代码，如果显式地提供了调用合约的状态变量，那么它只能访问这些变量(否则它将无法命名它们)。 如果库函数不修改状态(如果它们是视图或pure函数) ，则只能直接调用它们(即不使用 DELEGATECALL) ，因为库被认为是无状态的。 特别是，不可能destroy 一个库。
```

pragma solidity >=0.4.22 <0.7.0;

library Set {
  // We define a new struct datatype that will be used to
  // hold its data in the calling contract.
  struct Data { mapping(uint => bool) flags; }

  // Note that the first parameter is of type "storage
  // reference" and thus only its storage address and not
  // its contents is passed as part of the call.  This is a
  // special feature of library functions.  It is idiomatic
  // to call the first parameter `self`, if the function can
  // be seen as a method of that object.
  function insert(Data storage self, uint value)
      public
      returns (bool)
  {
      if (self.flags[value])
          return false; // already there
      self.flags[value] = true;
      return true;
  }

  function remove(Data storage self, uint value)
      public
      returns (bool)
  {
      if (!self.flags[value])
          return false; // not there
      self.flags[value] = false;
      return true;
  }

  function contains(Data storage self, uint value)
      public
      view
      returns (bool)
  {
      return self.flags[value];
  }
}

contract C {
    Set.Data knownValues;

    function register(uint value) public {
        // The library functions can be called without a
        // specific instance of the library, since the
        // "instance" will be the current contract.
        require(Set.insert(knownValues, value));
    }
    // In this contract, we can also directly access knownValues.flags, if we want.
}
```
下列代码展示了把Bigint封装为库
```

pragma solidity >=0.4.16 <0.7.0;

library BigInt {
    struct bigint {
        uint[] limbs;
    }

    function fromUint(uint x) internal pure returns (bigint memory r) {
        r.limbs = new uint[](1);
        r.limbs[0] = x;
    }

    function add(bigint memory _a, bigint memory _b) internal pure returns (bigint memory r) {
        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));
        uint carry = 0;
        for (uint i = 0; i < r.limbs.length; ++i) {
            uint a = limb(_a, i);
            uint b = limb(_b, i);
            r.limbs[i] = a + b + carry;
            if (a + b < a || (a + b == uint(-1) && carry > 0))
                carry = 1;
            else
                carry = 0;
        }
        if (carry > 0) {
            // too bad, we have to add a limb
            uint[] memory newLimbs = new uint[](r.limbs.length + 1);
            uint i;
            for (i = 0; i < r.limbs.length; ++i)
                newLimbs[i] = r.limbs[i];
            newLimbs[i] = carry;
            r.limbs = newLimbs;
        }
    }

    function limb(bigint memory _a, uint _limb) internal pure returns (uint) {
        return _limb < _a.limbs.length ? _a.limbs[_limb] : 0;
    }

    function max(uint a, uint b) private pure returns (uint) {
        return a > b ? a : b;
    }
}

contract C {
    using BigInt for BigInt.bigint;

    function f() public pure {
        BigInt.bigint memory x = BigInt.fromUint(7);
        BigInt.bigint memory y = BigInt.fromUint(uint(-1));
        BigInt.bigint memory z = x.add(y);
        assert(z.limb(1) > 0);
    }
}
```
相较于合约，库的限制：
- 没有状态变量
- 既不能继承也不能被继承
- 不能接收ether

### 库的调用保护
如果执行库的代码使用`CALL`而不是`DELEGATECALL`或者`CALLCODE`,除非调用的是`view`或者`pure`函数，否则会恢复 。

库的运行时代码总是以推送指令开始，在编译时该指令的值为20字节的0。 当部署代码运行时，这个常量在内存中被当前地址替换，并且这个修改后的代码存储在合约中。 在运行时，这导致将部署时地址作为推送到堆栈的第一个常量，并且对于任何非视图和非纯函数，调度程序代码将当前地址与此常量进行比较。

### using for
指令`using A for B;`用来关联库函数（A库）为任意类型（B）。这些函数将接收调用它们的对象作为第一个参数(如 Python 中的 `self` 变量)。

`using A for *;`的效果是来自库 A 的函数附加到任何类型。

在这两种情况下，都会附加库中的所有函数，即使第一个参数的类型与对象的类型不匹配。 在调用函数时检查类型，并执行函数重载解析。

通过这种方式扩展基本类型
```
ragma solidity >=0.4.16 <0.7.0;

library Search {
    function indexOf(uint[] storage self, uint value)
        public
        view
        returns (uint)
    {
        for (uint i = 0; i < self.length; i++)
            if (self[i] == value) return i;
        return uint(-1);
    }
}

contract C {
    using Search for uint[];
    uint[] data;

    function append(uint value) public {
        data.push(value);
    }

    function replace(uint _old, uint _new) public {
        // This performs the library function call
        uint index = data.indexOf(_old);
        if (index == uint(-1))
            data.push(_new);
        else
            data[index] = _new;
    }
}
```
